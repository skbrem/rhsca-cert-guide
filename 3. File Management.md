---
created: 2026-02-04
tags:
  - rhcsa
  - linux
---

## The File System Hierarchy

It's important to be familiar with the default directories that are found on almost all Linux systems. 

The layout of the directory structure in Linux is defined within the File System Hierarchy Standard, and more info about this system can be found with `man 7 file-hierarchy`.

A table breaking down the hierarchy found on most Linux systems:

| Directory | Description |
| --- | --- |
| / | This is the root directory, and the start of the file system tree. |
| /boot | This directory contains the files needed for the Linux kernel to boot. |
| /dev | Device files are foudn here, and are needed for accessing physical devices. It's needed during the boot process. |
| /etc | Configuration files found here are utilised by services and programs on the server, and it's a necessary directory for booting. |
| /home | Where the user's personal directories and files can be found. |
| /mnt, /media | Directories which are used for mounting devices within the system tree. |

## Mounts

A mount is the connection between a directory and a device. 

During the mounting process, a device is directly connected to a directory. Once the process is complete, the directory gives access to the newly-connected device. 

It's worth working with multiple mounts, as a single file system could run into issues like: 

- The file system could be filled up quickly from too much activity, bad news for a server. 
- It's bad OPSEC, where mounting allows for more granular security per mount. 
- It makes it easier to add more space to the system.

These reasons and more are why it's a good idea to split Linux file systems into different devices, including disk partitions and logical volumes. 

Certain directories are usually mounted on dedicated devices, including:

- **/boot**: Generally mounted on a different device as it contains special information that the computer needs to boot. As the `/` is commonly on an LVM (Logical Volume Manager), volume, where the OS is not able to boot by default, the kernel and other files will need to be stored elsewhere.
- **/boot/EFI**: If your PC or laptop makes use of EFI for the boot process, its own mount will be needed. 
- **/var**: Commonly on a dedicated device because it's able to expand dynamically in size. 
- **/home**: Kept on a dedicated device to ensure good security. It's possible to mount it with certain options like `noexec` and `nodec` which helps to better security. It's advantageous to have home directories in a separate file system when installing in order to make sure they survive the reinstallation of the system.
- **/usr**: Contains files for the operating system, and users normally do not need write access to this. It's a good idea to put this on a dedicated device which allows admins to configure this as a read-only mount.

It's common to find servers that have other directories mounted on partitions or volumes, and is usually up to what the admin feels is best. 

### Mount Points and Devices

Use the `mount` command to get an overview of all the mounted devices on the system. The `/proc/mounts` file is read to get the necessary information, and will show kernel interfaces too, leading to a large list of mounted devices. 

Reading available disk space on mounted devices can be done with the `df -Th command`, and is helpful to get an overview of all the file systems that are mounted. Using the `-h` option makes it human readable, and the `-T` option shows which file system type is used for the various mounts. 

The `findmnt` command will show mounts and the relationships between different mounts. This is a good alternative to `mount` because there is not quite as much information to absorb. 

#### The `df` Command

When using the `df` command, it will be displayed in seven columns, which includes:

- **Filesystem**: This is the name of the device file that interacts with the disk being used. The actual devices in the output start with /dev. It's also possible to see a few tempfs devices, which are kernal devices that are used to create a temp file system within RAM. 
- **Type**: The type of file system. 
- **Size**: The size of the mounted device. 
- **Used**: The amount of disk that the device has in use. 
- **Avail**: The amount of available space on the disk.
- **Use%**: The percentage of device that is currently being used. 
- **Mounted on**: The directory the device is mounted on at the time. 

> [!tip] 
> The sizes in `df` are reported in kibibytes. Use the `-m` option to display these in mebibytes. The `-h` option will display a human-readable format in KiB, MiB, GiB, TiB, or PiB. 

## Management of Files

The tasks for an admin include:

- Working with wildcards
- Managing and working with directories
- Working with absolute and relative pathnames
- Listing both files and directories
- Coping files and directories
- Moving files and directories
- Deleting files and directories

### Wildcards

A wildcard is a shell feature that helps the user refer to many files in a simple way. 

| Wildcard | Use | 
| --- | --- |
| * | An unlimited number of characters. Using a command like `ls *`shows all of the files in the current directory with the exception of those that start with a dot. |
| ? | Used to refer to one specific character that can be any character. `ls m?d` would match with *mad* and *mud*. |
| [auo] | One character that may be selected from the range that is specified between square brackets. `ls m[auo]` may refer to mad, mud, or mod. |

### Working with Directories

Linux works with directories in order to organise files. It's important to be able to walk through the directory structure. 

> [!note]
> - **Absolute path**: Also known as an absolute pathnames/filenames, this is the complete path reference to a directory or file. It begins at the root directory, and will include all the subdirectories leading up to the current working directory or filename. 

> [!note]
> - **Relative path**: This is relative to the current directory, shown with the `pwd` command. Possible to get from the current directory up to the file that's needed. 

When working with relative pathways, it's helpful to be able to move up one level from where you are. Let's take the example of being logged in as root and wanting to copy the file /home/steve/file.txt to the directory /home/john. The following solutions will allow you to do this:

- Use `cp /home/steve/file.txt /home/john`. As we are using absolute pathnames, this command will always work.
- If the current directory is /home, use `cp /steve/file.txt john`. Both the source file and the destination file are referred to as relative pathnames and for that reason do not start with a /. However, if the directory john does not exist, the `cp` command will create a file with the name john. To ensure that it copies to a directory and generates an error if one does not exist, use `cp steve/file.txt john/.
- If the current directory is set to /home/steve, it's possible to use `cp file.txt ../john`. The name of the target file uses `..` which instructs it to go up on level. Followed by /john, so it's interpreted as going up on level and then look for the /john subdirectory. 

### Listing Files and Directories

| Command | Use |
| --- | --- |
| `ls -l` | Long listing, including info about file properties like permissions and creation date. |
| `ls -a` | Shows all of the files in the directory, which includes hidden files. |
| `ls -lrt` | Here, the `-t` option shows commands that are sorted by their modification date. The most-recently modified files will be shown last because of the `-r` option. |
| `ls -d` | This shows the names of directories, but not the contents of all directories that match the wildcards which are used with the `ls` command. |
| `ls -R` | Shows the contents of the current directory as well as all of its subdirectories. It **R**ecursively descends all of the subdirectories. |

When using the `ls` and `ls -l` commands, the files will sometimes be coloured. This is done to help differentiate between the different file types. This is different in other shells and servers. 

### Copying Files and Directories

The `cp` command is used to organise files on a server. To copy a single file, do the following:

` cp /<path-to-file> /<path-to-destination`. 

> [!tip] 
> Trying to copy a file to a directory that does not exist will instead create a file with the name of that directory. This is not ideal and it would be better to get an error message to show. Always place a / after directory name to accomplish this, so:
> 
> `cp /etc/hosts /tmp/` rather than `cp /etc/hosts /tmp`

It's possible to copy a whole subdirectory with the `cp` command. To do this, use the `-R` option, which stands for recursive, and it's an option that's used with many other Linux commands. 

Use the `-R` option with something like copying the /etc directory and all of its contents to the /tmp directory by using the `cp -R /etc /tmp` command. 

The `cp` command needs to done while considering the permission and other properties of the files. Without certain options, it's possible to lose these properties as they will not be copied across. 

In order to make sure that the current permissions are preserved when coping, use the `-a` option, which makes `cp` work in archive mode. 

Another thing to keep in mind with using `cp` is hidden files. By default, hidden files are **not** copied over, but there are solutions, including:

- `cp /somedir.* /tmp`: which copies all files that have a name starting with a dot to /tmp. It will show an error message for directories that have names with a dot in /somedir, because the `-R` option was not used. 
- `cp -a /somedir/ .`: Copies the entire directory of /somedir, including all of its contents, to the current directory. A subdirectory called *somedir* will be created in the current directory.
- `cp -a /somedir/. .`: Copies all files, both regular and hidden, to current directory. (there is a space between the two dots at the end of the command.)

### Moving Files and Directories

The `mv` command is used to move files and directories, which moves from the current location and to a new location. It's also the command used to rename a file, which is nothing more than copying and deleting the original copy. How it works:

- `mv file /tmp`:  Moves the file *file* from the current directory to /tmp.
- `mkdir newdir; mv newfir /tmp`: Which creats a directory called *newdir* and then moves this directory to the directory /tmp. This will work if the source directory contains files.
- `mv file1 file2`: Renames the file. 

### Deleting Files and Directories

The command `rm` is used to delete files and directories. Use the `-r` option to delete directories that contain files. 

On RHEL, when using the `rm` command as root, it will ask for confirmation. This is because the `rm` command is defined with the alias `rm -i`. It's possible to stop this behaviour using `-f` or to change the alias. Probably better to simply leave as it as it provides a chance to review the command being executed. 

## Links

Links work similarly to aliases in that they are aliases that are assigned to a file. There are both hard links and symbolic links, and it's important to understand both. 

### Hard Links

All admin data about files is stored as inodes. Every file on a Linux system has an inode attached to it. The inode contains information about the file, including:

- Permissions
- File owners
- Date of creation, access, and modification
- Date block where the contents of the file are contained

The name of the file, however, is not stored in the inode. 
